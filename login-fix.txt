ğŸ” Login System â€“ What Was Actually Fixed
1ï¸âƒ£ Supabase auth was working the whole time

Supabase successfully authenticated the user

You could see the UID in Supabase

Errors like â€œemail already registeredâ€ proved auth itself was fine

ğŸ‘‰ The problem was not Supabase

2ï¸âƒ£ Flask-Login session wiring was broken

Initially:

User could authenticate

But Flask-Login could not reliably reload the user on new requests

Result: user appeared logged out on some pages

Fixes:

Ensured login_user(user) is called after Supabase login

Stored Supabase UID as the Flask-Login user ID

Marked the session as permanent

Confirmed _user_id is present in session

3ï¸âƒ£ User loader was failing intermittently

Root cause:

The user_loader tried to fetch the user from PostgreSQL

PostgreSQL connection pool was exhausted

When DB lookup failed, Flask-Login treated the user as â€œnot foundâ€

That caused:

redirect back to landing page

login state flickering

â€œsession mismatchâ€ logs

Key realization:

Login state wasnâ€™t lost â€” user reload was failing.

4ï¸âƒ£ Database connection pooling was the real breaker

Original DB code:

Used pool.getconn() without always calling pool.putconn()

Stored connections on self.conn

On Render free tier (maxconn=2), this exhausted the pool quickly

Symptoms:

psycopg2.pool.PoolError: connection pool exhausted

User loader failures

Auth appearing to randomly fail

5ï¸âƒ£ Connection lifecycle was refactored

Fix implemented:

Introduced managed connection / cursor handling

Ensured every getconn() has a matching putconn()

Stopped storing pooled connections on self

Updated all auth-related DB methods to use the safe pattern

This stabilized:

get_user_by_id

get_user_by_supabase_uid

Flask-Login user_loader

6ï¸âƒ£ Result after fixes

After this:

Login succeeds consistently

Session persists while browser is open

User reload works across routes

Data is correctly scoped by user ID

Drafts and listings can be tied to the user in the DB

Remaining issues (separate from login):

Frontend flicker due to session-check polling

UI routing showing logged-out landing page briefly

Color / layout work (non-auth related)
ğŸ” AUTHENTICATION & SESSION FLOW â€” CANONICAL DIAGRAM
0. Ground rules (these never change)

Supabase = authentication only

PostgreSQL = application data only

Flask-Login = session authority

Redis = session storage

Browser cookies = session pointer only

User data is always scoped by user_id

No code stores DB connections on self

If any rule above is broken, login instability is expected.

1ï¸âƒ£ Login request flow (POST /login)
Browser
  â†“
POST /login (email, password)
  â†“
Supabase auth.sign_in()
  â”œâ”€ FAIL â†’ return error (no DB, no session)
  â””â”€ SUCCESS â†’ supabase_uid
        â†“
Postgres: get_user_by_supabase_uid(supabase_uid)
  â”œâ”€ NOT FOUND â†’ create user row (with same supabase_uid)
  â””â”€ FOUND â†’ continue
        â†“
Flask-Login: login_user(user)
        â†“
Session (Redis):
  - _user_id = supabase_uid
  - permanent = False
        â†“
302 redirect â†’ / (or /create)


Hard requirements

login_user(user) MUST be called

_user_id MUST equal supabase_uid

No DB connections remain open after request

2ï¸âƒ£ Request authentication on EVERY page load

For every request after login:

Incoming HTTP request
  â†“
Flask-Login user_loader(user_id)
  â†“
Postgres: get_user_by_id(user_id)
  â”œâ”€ SUCCESS â†’ current_user populated
  â””â”€ FAIL â†’ treated as logged out


Important

If DB lookup fails for any reason, user appears logged out

This is why DB connection stability is critical

3ï¸âƒ£ Session persistence rules (THIS IS WHERE BUGS HIDE)
What SHOULD happen
Action	Result
Refresh page	Still logged in
Navigate pages	Still logged in
Close tab	Still logged in
Close browser	Logged out
Clear cookies	Logged out
Redeploy app	Logged out (session invalidated)
Required configuration

Flask session cookie:

permanent = False

SESSION_COOKIE_SECURE = True

SESSION_COOKIE_HTTPONLY = True

Redis stores session server-side

Browser only holds session ID

4ï¸âƒ£ Data storage (this is NOT session)

Sessions â‰  user data

User data flow:

Action (draft, listing, inventory)
  â†“
Authenticated request
  â†“
current_user.id (supabase_uid)
  â†“
Postgres / Supabase table
  - user_id = current_user.id
  - data isolated per user


Key rule

Clearing browser cache NEVER deletes user data

Redeploy NEVER deletes user data

Only deletes happen via DB logic

If data disappears, it is not auth â€” it is storage logic.

5ï¸âƒ£ Failure diagnosis map (use this when login breaks)
Symptom: â€œLogin works once, then kicks me outâ€

â†’ Check:

DB connection pool exhausted

user_loader DB call failing

Missing putconn()

Symptom: â€œSome pages think Iâ€™m logged in, others donâ€™tâ€

â†’ Check:

Template logic using current_user

JS calling /api/auth/session too aggressively

Landing page overriding auth state

Symptom: â€œLogin flickers / white screenâ€

â†’ Check:

Frontend polling /api/auth/session

Redirect loop when current_user undefined briefly

Page reload triggered before session resolves

Symptom: â€œEveryone sees same dataâ€

â†’ Critical failure:

Data tables missing user_id filter

Queries not scoped by current_user.id

6ï¸âƒ£ Non-negotiable invariants (print this)

Supabase UID == Flask-Login user_id

Every getconn() has a putconn()

user_loader must never leak connections

Session is authority, not frontend state

User data always lives in DB, never in session

7ï¸âƒ£ What to tell Cursor / Claude (exact words)

You can hand them this exact sentence:

Follow the authentication diagram exactly. Do not invent new session logic. Supabase authenticates, Flask-Login owns session state, Redis stores sessions, PostgreSQL stores user data scoped by user_id. If login breaks, trace the diagram step by step and fix the first violated invariant.